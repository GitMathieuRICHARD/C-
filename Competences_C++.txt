Plan de cours Qt Core Advances - C++

Plan cours :

Gestion des threads / sockets
UDP Programming
Thread Pool
SSL SOCKETS
Création de librairies
Utilisation de MySQL
Insertion, supression et interrogation de données dans une base de données
Test unitaire
Tests pilotés par les données
Déploiement d'application sur Windows, Mac et Linux
Application Images
Framework Qt Installer
Techniques avancées C++
Gestion de la concurrence
Programmation TCP
Programmation Client / server
Deisgn TCP Multi-threadé
Creation de certificat SSL
Creation de bibliothèques dynamique et partagé
Extension QT application avec plugins
Plugins base de données
Test des pilotes de base de données
Framework Qt Test
Bencharmking
Static build
Compression des binaires d'application

/* ----------------------------------------------------------------------------------- */

Plan de cours SQL :

Plan de cours :

Maîtriser l'essentiel du langage SQL pour extraire des données depuis des bases de données 

Extraire des données depuis n'importe quelle base de données en SQL
Grouper des données pour effectuer des calculs sur chaque groupe
Utiiser les bases de données SQL dans un but marketing
Toutes les bases SQL : afficher des colonnes depuis une table, créer des condtions, tirer les donénes
Combiner des tables à l'aide de la commande JOIN


/* ----------------------------------------------------------------------------------- */

Plan de cours C++ :

Plan de cours :

Nouveautés fondamentales de la norme C++11/14

    nullptr_t et le littéral nullptr
    Les nouveaux types, littéraux et séparateurs
    Variables templates
    Initialisation uniforme
    Initialisation de tableaux et collections
    Parcours unifié des tableaux et conteneurs
    Listes d’initialisation avec initializer_listT>
    La boucle "range based" for
    Énumérations fortement typées
    Types normalisés et variantes (uint_8, uint64_t, ...)
    Contrôle de l’alignement mémoire
    Inférence de types et de signatures avec auto
    C++14 et déduction étendue
    Les nouveaux spécificateurs de classe (override, default, delete, final)
    Constructeur délégué
    Constructeur hérité
    Alias et using
    Expressions constantes avec constexpr
    Gestion du temps, l’espace de nom chrono

Move semantics

    Copie versus déplacement
    Value et RValue reference
    La fonction move
    Move constructor et move assignement operator
    Héritage et move constructor / op=
    STL C++11 et swap / move
    Signature reference qualifiers
    Mauvaises pratiques

Gestion des ressources

    Resource Acquisition Is Initialization (RAII)
    L’opérateur -> avec ou sans généricité
    Propriété et transfert de responsabilité
    La classe unique_ptr
    Unique_ptr et tableaux dynamiques
    Comptage de références avec la classe shared_ptr
    Custom deleter
    Les fonctions make_unique (C++14) et make_shared
    La classe weak_ptr et le référencement circulaire

Gestion avancée des exceptions

    Principes
    Dynamique
    Traiter une exception
    Concevoir et hiérarchiser les exceptions
    Traitement par défaut
    Les exceptions prédéfinies
    Abraham’s Exception safety guarantees
    La clause C++11 noexcept

Héritage avancé

    Surcharge et ambiguïtés
    Héritage public et redéfinition privée
    Héritage privé et protégé
    Héritage multiple
    Héritage en diamant
    Héritage virtuel et dominance

Programmation fonctionnelle avec C++ 11/14

    Problématique de l’abonnement
    Les classe function et mem_fn
    Binding, placeholders
    Adaptateurs de références
    Les lambda-expression

Utilisation avancée de la généricité

    Typage multiple
    Inférence des retours avec decltype
    Paramétrage / spécialisation des méthodes
    Perfect forwarding avec std::forward
    Héritage / containment et généricité
    Méta-programmation
    L’idiome CRTP Curiously Recursive Template Pattern
    Typologie C++ et classes de traits
    Assertions statiques avec static_assert
    Extended friend declaration
    Les variadic templates, pattern matching et héritage multiple
    SFINAE Substitution Failure Is Not An Error

Nouveautés C++11 de la librairie standard

    Les nouveaux itérateurs cbegin
    Les tableaux à taille fixe avec std ::array
    Les nouvelles collections associatives : unordered_map/set
    Singly-Linked Lists
    Le conteneur tuple
    Adaptateurs d’itérateurs, stream itérateurs
    Les nouveaux algorithmes ensemblistes

Multithreading

    Principes
    Démarrage et détachement d’un thread
    La classe std ::call_once
    L’espace de noms this_thread
    Futures / promises et packaged_task
    Programmation asynchrone avec async
    Politiques de démarrage
    Comparaison thread versus future
    Partage de ressources et mécanismes de synchronisation
    Mutexes et données atomiques
    Unique-lock et lock_guard

Approche Test Driven Design (TDD) en C++ avec GoogleTest

    Concepts
    Assertions et tests élémentaires
    Tests multiples : suites de tests et Test Cases
    Préparation et mutualisation des tests avec les Test fixtures

/* ----------------------------------------------------------------------------------- */

Les classes en C++

Constructeurs et allocation mémoire
Forme canonique d'une classe
Rôle du constructeur de copie
Surcharge de l'opérateur d’affectation
Intérêt d'un destructeur virtuel
Pièges à éviter

Travaux Pratiques :

Exécution d'exemples pédagogiques illustrant les concepts présentés
Les conversions en C++

Présentation des conversions, syntaxe
Utilisation du const_cast pour enlever un caractère const
Utilisation du static_cast pour effectuer une conversion standard
Utilisation du reinterpret_cast pour effectuer une conversion forte
Utilisation du dynamic_cast dans une hiérarchie de classes

Travaux Pratiques :

Choix du type de cast et mise en œuvre dans différentes situations 
L’identification de type à l'exécution (RTTI)

Principe et cas d'utilisation
Utilisation du dynamic_cast pour effectuer un downcast dans une hiérarchie de classes
Utilisation de l'opérateur typeid et de la classe type_info

Travaux Pratiques :

Mise en œuvre de RTTI pour effectuer un affichage spécifique d'un objet faisant partie d'une hiéarchie de classes
Les pointeurs sur membres de classes

Syntaxe des pointeurs sur membres de classes
Mise en œuvre

Travaux Pratiques :

Utilisation de pointeurs sur méthodes pour effectuer des calculs mathématiques
Les pointeurs intelligents (smart pointers C++11)

Danger des pointeurs nus
Principe de la gestion de ressources
Intérêt des smart pointers
Raisons de l'obsolescence de auto_ptr
Mise en œuvre de unique_ptr, shared_ptr et weak_ptr

Travaux Pratiques :

Remplacement, dans une application, de pointeurs nus par des pointeurs intelligents
La gestion des exceptions

Principe des exceptions
Les classes d'exceptions
Comment lever une exception
Gestionnaires d'exceptions
Liste d'exceptions
Hiérarchies d'exceptions
Classes d'exceptions standards
Constructeurs et exceptions
Exceptions et gestion des ressources
Bonnes pratiques

Travaux Pratiques :

Mise en place d'une gestion d'exceptions dans une application effectuant des entrées-sorties
Les templates

Présentation
Avantages/inconvénients
Syntaxe des templates de fonctions
Syntaxe des templates de classes
Syntaxe des templates de méthodes
Instanciation des templates de fonctions
Instanciation des templates de classes
Spécialisation partielle ou totale des templates

Travaux Pratiques :

Mise en œuvre d'une fonction template
Mise en œuvre d'une classe template
Mise en œuvre d'une classe template template
Introduction aux Design Patterns (avec zoom sur certains)

Présentation des patterns du GoF
Patterns de création
Patterns de structure
Patterns de comportement

Travaux Pratiques :

Mise en œuvre des patterns Singleton, Factory Method, Abstract Factory
Mise en œuvre des patterns Visitor, Proxy
Les foncteurs

Présentation
Intérêt des foncteurs
Foncteurs prédéfinis dans la bibliothèque standard
Utilisation d'adaptateurs de fonctions unaires et binaires

Travaux Pratiques :

Mise en œuvre d'un foncteur avec l'algorithme for_each pour afficher le contenu d'un vector
La bibliothèque STL

Présentation de la Standard Template Library
Les conteneurs
Les allocateurs
Les itérateurs
Les algorithmes
Les entrées-sorties

Travaux Pratiques :

Mise en œuvre de quelques conteneurs, d'algorithmes et template d'entrées-sorties
Les idiomes

Traits
Policy
SFINAE (Substitution Failure Is Not An Error)
CRTP (Curiously Recurring Template Pattern) : pour le polymorphisme statique

Travaux Pratiques :

Mise en œuvre de chacun des idiomes
La méta-programmation

Comment exécuter à la compilation
Avantages/inconvénients
Optimisations

Travaux Pratiques :

Mise en œuvre de la méta-programmation pour effectuer des calculs mathématiques par le compilateur
La bibliothèque Boost

Présentation
static_assert
property_map
smart_ptr
tuple
any
variant
threads
interprocess
mpl (méta programming language)

Travaux Pratiques :

Mise en œuvre de quelques templates de Boost
Nouveautés essentielles du C++11 

Mot-clés auto, decltype et constexpr
Définition des rvalue références
Application des rvalue références : déplacement et transfert parfait
Bonne utilisation de std::move et std::forward
Les fonctions lambda
Les variadic templates

Travaux Pratiques :

Mise en œuvre des mot-clés auto, decltype et constexpr
Mise en œuvre des références rvalue pour la création et la copie d'objet par déplacement
Mise en œuvre des expressions lambda en remplacement des foncteurs
Mise en œuvre des variadic templates
Autres nouveautés du C++11 

Initialisation des données membres non-statiques
Alias de template
Constructeurs délégués
Déclarations étendues de l’amitié
Surcharge explicite de la virtualité
La constante nullptr
« Range-based » for
Définition des rvalue références
Les opérateurs de conversion explicites
Les types POD (Plain Old Data) revisités
Les types locaux et non nommés comme arguments template
Les énumérations à typage fort
Les fonctions par défaut et supprimées (=default, =delete)
Les espaces de nom inline
La propagation des exceptions (dans le cadre du multithreading)

Travaux Pratiques :

Mise en œuvre d'une partie de ces nouveautés dans une application existante
Performances

Introduction
Résumé des bonnes pratiques


